Python Basics:

there are 3 ways to execute python programmes
1.Using interactive interpreter:
    Enter python in the command line to start interactive interpreter session and type python code
    $ python          # Unix/Linux
    c:\>python        # windows/DOS 
    To exit interactive interpreter use ctrl-z(on windows),ctrl-D(on unix)
2.Script from the command line:
   write your python programme in somewhere and save the file with .py extension then run the file in the command prompt
   $python script.py         # Unix/Linux
   c:>python script.py       # windows/DOS
  Note:Be sure the file permission mode allows execution
3.IDE(Integrated development environment):
   we can run python from from Graphical user interface provided by integrated development environment(IDE)
   IDLE is a popular IDE that ships along with python distribution
   PyDev is a plugin for eclipse that turns eclipse into a full-fledge python IDE.Both Eclipse and PyDev is cross-platforms and open source
   
Identifiers:
  Identifiers are used to identify the variables,functions,class,module,or any other object.
 Naming Rules:
1.Variable name should be anything.
2.identifier names should start with Alphabets or underscores(_) followed by zero or more letters,underscores and digits.
3.No other Special characters are allowed.
4.identifier names are case sensitive.

Lines and Indentation:
  There are no braces,any keywords to indicate block of code for class and function definations or flow control.
  The number of Spaces in the indentation is variable,but all the satements within the block needs to maintain the same number of indentations otherwise it will 
  throw an indentation error.

Multiline statments:
  days="Sunday" + \
        "Monday" + \
        "Tuesday"
 if we use [],{} or (),we dont want to use the line continuation character example below
  days=["Sunday","Monday","Tuesday"]
  
Reading input's from User:
  The input(string) method returns a line of user input as a string.
  The string can be converted by using the conversion method such as int(string),float(string),and so on..
  Ex:
     print("Hey,What is you're name?")
     name=input(" ")
     print("What is you're age?")
     age=int(input(" "))     # here we are giving age,so it is integer even though we used double quotes here without mentioning those quotes also it is taking input.
     #formatted printing with format method
     print("Hi %s! you're %d years old!.format(name,age))      # But this formatting method is not working for me
  
Decision making statements:  (pending)
  1.if  :An if statement consists of boolean expressions followed by one or more statements.
  2.if else  :An if statement followed by an else statement,which executes when the boolean expression is false.
  3.if elif else :Multiple if statements that allows to check multiple expressions for a truth value and an optional at the end.
  3.nested if :
Loops and Loop control statements:
-----------------------------------------------------

Functions:
  Functions is a set/group of statements which are reusable and is used to perform a task.
  1.Function block begins with def keyword followed by function name and parentheses (()).
  2.Any input parameters/Arguments placed with-in these parameters.
  3.First statement of a function can be optional statement - the documentation string of the function or docstring.
  4.The code block within every function starts with colon (:) and indented.
  5.Functions may return a value to the user by using of 'return' keyword.
 There can be two types of data passed in the function.
  1.First type of data is the data passed in the function call.This data is called Arguments.
  2.Second type of data is the data recieved in the function defination.This data is called parameters.
 Arguments can be literals,Variables and expressions.Parameters must be variable to hold incoming values.
 Alterantively,arguments can be called as actual parameters or actual arguments and parameters can be called as formal parameters or formal arguments.

Ex:
    def Viswa(str):
        print(str)
        return
    Viswa(str)
   In above example Viswa is function name and (str) are the input parameters.

  After defining function we are able to call it from another function or directly from the python prompt.
 Ex1:
    def my_fun(str):
        print(str + "Viswa")
        return
    my_fun("Hi")
    my_fun(("How are you")
 output:
    Hi Viswa
    How are you Viswa
 Ex2:
   def myfunc(int)
       print(int + " Viswa")
       return
   myfunc(23)
   myfunc(42)
 output:
    TypeError: unsupported operand type(s) for +: 'int' and 'str'
   will get above error as bcz not possible to concatinate int and string,To overcome issue like below
 Ex3:
    def myfunc(int)
       print(int + " Viswa")
       return
   myfunc("23")
   myfunc("42")
  output:
    23 Viswa
    42 Viswa
Note" we just take input as like string then it will easily concatenate with the string (Viswa)

Passing Arguments to functions:
  1.keyword arguments
  2.default arguments
  3.pass by reference vs value 
  4.variable length arguments
 1.Keyword arguments:
    Ex1:
       def myfunc(a,b):
           result=a+b
           return result
       myfunc(20,30)
       myfunc(20,20)
   output:
         40  # it is printing only last condition
      
  Ex2:
       def myfunc(str):
           print(str)
           return
       myfunc(str="pora")
  o/p:
      pora
  
  Ex3:
      def emp(name,age):
          print(name)
          print(age)
          return
     emp("Ashok",24)
 o/p:
     Ashok
     24

  Ex4:
       def myfunc(a,b):
           result=a+b
           return result
       print(add(a=25,b=35))     # as per google i wrote this
       print(add(a=45,b=20))
   output:
         NameError: name 'add' is not defined   # got the error
 2.Default arguments:
    I had done example same as above example 2 with small modifications ( instead of plus i used divided and i kept b value as 2 while passing arguments bcz it is 
     default arguments so that i kept b as default value while creating function )
    Ex:
       def myfunc(a,b=2)
           result=a/b
           return result
       myfunc(20)
       myfunc(30)
    output:
          15
 Note: Only last function is executing
 Note:if i use print(divide(20))
      then i am getting Name error same as above
  Ex:
     def myfunc(Name,Age=24):
         print(Name)
         print(Age)
         return
     myfunc("Viswa",23)
     myfunc("Madhu",25)
     myfunc("Harsha")
     myfunc("Surfam")
  o/p:
     Viswa 23
     Madhu 25
     Harsha 24
     Surfam 24

 Note:in above example i passed an age argument as default value if we mention age so it will print otherwise default value age got printed.

 3.Pass by reference vs value:
    Ex:
         def myfunc(mylist):
             mylist.append[1,2,3,4]
             print("Values inside the function :",mylist)
             return
         mylist=[10,20,30]
         myfunc(mylist)
         print("Values outside of the function :",mylist)
   Output:
        TypeError                                 Traceback (most recent call last)
        <ipython-input-79-13ba5c03f401> in <module>()
        4     return
        5 mylist=[10,20,30]
  ----> 6 myfunc(mylist)
        7 print("Values outside of the function :",mylist)

       <ipython-input-79-13ba5c03f401> in myfunc(mylist)
       1 def myfunc(mylist):
  ---->2     mylist.append[1,2,3,4]
       3     print("Values inside the function :",mylist)
       4     return
       5 mylist=[10,20,30]

       TypeError: 'builtin_function_or_method' object is not subscriptable.

 4.variable length Arguments:
      You may need to process a function for more arguments than you specified while defining the function. 
      These arguments are called variable-length arguments and are not named in the function definition, unlike required and default arguments.

  Syntax:
     def myfunc([formal_args,] *var_args_tuple):
   
    Note:An asterisk (*) is placed before the variable name that holds the values of all nonkeyword variable arguments. 
         This tuple remains empty if no additional arguments are specified during the function call.
  Ex:
     def myfunc(int,*vartuple):
         print(int)
         for var in vartuple:
             print(var)
         return
    myfunc(10)
    myfunc(23,56,"Hello","V")
 o/p:
    10
    23
    56
    Hello
    V
  5.Anonymous Functions:
    these are called as Anonymous bcz they are not declared in the standard manner by using of def keyword.we can use keyword lambda to create anonymous functions
    Anonymous functions does not has a name.
    1.lambda function can take any number of arguments but returns just one value in the form of an expression.they can not contain commands or multiple expressions.
    2.An anonymous function cannot be a direct call to print because lambda requires an expression
    3.Lambda functions have their own local namespace and cannot access variables other than those in their parameter list and those in the global namespace.

  Syntax of anonymous function:
    lambda [arg1[,agr2[,arg3,....argn]]]:expression

  Ex:
     sum=lambda arg1,arg2:arg1+arg2;
     print("value of total:",sum(10,20))
     print("value of total:",sum(41,89))
 o/p:
     value of total: 30
     value of total: 130

 Return Statement:
   The return statement exists a function,optionally passing back an expression to the caller.A return statement with no arguments is the same as return None.
 Scope of variables:
   All variables in a programme may not be accessible at all locations in that program.this depends on where you have declared a variable.
   There are two basic scopes of variables in python.
     1.Global Variable
     2.Local Variable
  
  Global vs Local Variables:
   Variables that are defined inside a function body have a local scope, and those defined outside have a global scope.
   local variables can be accessed only inside the function in which they are declared.
   global variables can be accessed throughout the program body by all functions.  
   


                                FUNCTIONS INSTITUTE:


in python we can call functions by using function name or another name that stores address of the function.
syntax:
  def myfun(a,b):
    sum=a+b
    print(sum)
    return sum
myfun(10,20)
myvar=myfun
print(myvar)
Note: myvar is refernce variable of our function so will assign myfun to myvar so that we can call our function like above example
   Ex:
      def fun():
          pass
      fun()
Note:Above function is empty,pass keyword indicates we are not using this function now will save this function for future.

Function will take parameters def myfun(a,b)
                             def is keyword to define the function
                             myfun is the function name
                             a,b are the function parameters
We have three types of parameters:
  1)Non-Default Parameters:
      while defining the function will just pass parameters not its values will pass those values while calling the function.

        def myfun(a,b):        ##here a,b are non-default parameters
            c=a+b
            print(c)
            return c
        myfun(10,25)
  2)Default Parameters:
      at the time of defining function will pass the value whether it is one or more arguments
    Ex:    
        def myfun(a,b=24)
            c=a+b
            print(c)
            return c
        myfun(10)           #here we pass value for a and b value is already passed at the time of creating
        myfun(10,45)        #here we pass values for both a and b,if we didn't pass b value it will take default argument
   Ex:
        def myfun(a=24,b):
            c=a+b
            print(c)
            return c
        myfun(34)           #After defining default parameter we are not allowed to define Non-Default parameter if will do that will get syntax error.

  3)Orbitary parameter:
      Any parameter which is precided by a* (or) ** known as orbitary parameter
      Orbitary parameter by default consider as a tuple
         def myfun(*a)     --Singlestar orbitary parameter
         def myfun(*a,b)   --Singlestar orbitary parameter 
    If we enter n no.of values we enter it will store in "a",so to over come that defining b value as default need to follow below syntax
         
         def myfun(b,*a)  -here first value will assigned to b and remaining all values stored in "a" 

         def myfun(**a)  --Multistar orbitary parameter
         In Multistar parameter it stores data in dictionary's,so we have to pass values in both key and value pairs.

         Whatever the values that we are passing at the time of calling functions known as "Arguments"         
           
   Two types of Arguments:
       1)Non-Keyword (or) Positional arguments:
           it will give values to first argument to first parameter and second argument to second parameter.
            def myfun(Name,msg):
                print("Hello",Name,msg)
                return
            myfun("Viswa","Good Morning")        

       2)Keyword (or) Non-Positional arguments:
            Here we need to specify which argument is passed to which parameter.
             def fun(Name,msg):
                 print("Hello",Name,msg)
                 return
             fun(msg="How are you",Name="Viswa")
   After passing Non-Keyword argument we can pass keyword argument but not vice-versa.

   Ex:
        def fun(*a,**b):
            print(*a)
            print(**b)
            return
        courses=["java","python","django"]
        info={"Name":"Viswa","Age":24}
        fun(courses,info)
   o/p:
        ['java', 'python', 'django'] {'Name': 'Viswa', 'Age': 24}

In above example whenever we enter values in list and dictionary format python interpretor automatically sets the list values as singlestar orbitary element
 and dictionary values as multistar orbitary elements these techinque is called unpacking.
If we call function fun(*courses,**info) in above example will get o/p like below
   Ex:
      def fun(*a,**b):
          print(a)
          print(b)
          return
      courses=["java","python","django"]
      info={"Name" : "Viswa","Age":24}
      fun(*courses,**info)
 o/p:
     ['java','python','django']
     {'Name':'Viswa','Age':24}

  Ex:calculating leap year by using functions:
       def leapyear(year):
           print(year % 4==0 and(year % 100!=0 or year % 100 == 0))
           return
       leapyear(2000)
  o/p:
      True
     

           def fun(var1,var2,.....varn):
               """doc str"""       #optinal - it is description of the function
               str1
               str2
               .
               .
               .
               strn
               return              #optional 

  if we need to return any statement then we have to use return statement then only we can use that returned value in anywhere in our application
  
           def fun(a,b):
               c=a+b
               d=c
               print(d)
               return c
           fun(10,20)

    o/p:
           30

  Note:1)whenver we call function,control will go to functionname and it will execute that function & control will comes out from the function once the return statement 
         executed then control will come out from function
       2)if we didn't mention any return statement by default python interpretor provides return statement so control will come out after default return 
         statement executed.
       3)only return statement executed at a time.

  Local & Global Variables:
      1)Global variables memory will be created only once.
      2)Local variables memory will be allocated whenever we call function.

 Ex:
    
   a=200
   def f1():
       global a
       a=100
       print(a)
   def f2():
       print(a)

Note:here we didnt mention variable a in "f2" function so we are calling global variable that we changed in "f1()" function,changed variable stored in global variable
     bcz we mention statement "global a" so changed variable store in globally.

 Infinite Recursion :
   def f1():
    print("Welcome")
    f1()
 f1()

Note:Here we are calling function inside function so it will print "welcome" msg infinite times and throws an error at some point of time bcz some memory issue.

 Exxx:
     def fun(greeting):
         return '{} Function.'.format(greeting)
     print(fun("Hi"))
 o/p:
     Hi Function.
 Exxx:
    def fun(greeting,Name="you"):
        return '{},{}.'.format(greeting,Name)
        print(fun("Hey"))
 o/p:
     Hey,you.
Anonymous (or) Lambda function:
 Lambda function dont have any name & it is created without proper syntax.
Syntax of lambda function :
  lambda var1,var2,.....varn:expression
it will take n no.of arguments as i/p and generates one o/p as an expression of all i/p's

 Ex:
    myfun=lambda p:p*p
    a=myfun(10)
    print(a)  
 lambda function doesnt store values so we created variable a in above example and we can call it anywhere.
 lambda function is used to pass one function parameter to another function 
  Ex;
     def cube(a,fun):
         p=fun(a)
         return p*a
     a=cube(10,lambda b:b*b)
     print(a) 
     y=cube(25,lambda b:b*b)
     print(y)

 Filter function:
   it is a type of function,it takes two parameters
    1)Function type parameter
    2)Iterable value

  filter function takes iterable value [list] and takes that value to functions,if the function satisfies the condition then it will return the value,if not satisfied 
  then it won't print.
  filter function working based on condition not expression.
    a=[1,2,3,4,5]
    res=filter(lambda p:p%2==0,a)
    print(res)
 Map function:
  map function takes iterable value [list] and takes that value to function,and written wheather it is false or true.
  map function working based on expression not condition.
  Ex1:
    a=[1,2,3,4,5]
    res=map(lambda p:p*p,a)
    print(res)
  Ex2:  
    a=[[100,"Book",1024],[101,"Car",4321],[102,"Bike",6754]]
    a.sort(key=lambda p:p[1],reverse=True)
    print(a)
 Note:Will get product details in descending order based on Product Name.
  
-------------------------------------------------------------------------
 Module:
   module allows to logically organize the python code.grouping related code into a module makes the code easier to understan and use.
   Simply module is a file consisting of python code,A module can define functions,classes and variables a module can also include a runnable code.
   need to import module if we need by using below syntax
        import module1[, module2[,...moduleN]]
   A module is loaded only once regardless of the number of times it is imported.this prevents the module execution from happening over and over again if 
   multiple imports occur
 From-import Statement: 
   python from statement allows to import specific attribute from a module into the current namespace.
   syntax of from..import is:
      from modname import name1[, name2[,...nameN]]
   it is also possible to import all names from a module into the current name space by using following import statement 
      from modname import *

   example:
       to import fibonacci function from the module fib,the statement used is:
          from fib import fibonacci 
            this statement does not import entire module fib into the current namespace;it just introduced the item fibonacci from module fib into global symbol table 
            of the importing table

 Locating modules:
   when user import python module,python interpretes searches for that module in mentioned sequence.  
    1.The current directory
    2.if the module is not found,it searches in the each directory in the shell variable PYTHONPATH
    3.if all fails,python searches for the default path.on UNIX default path is normally 
        usr/local/lib/python/.
 The python path is an environment variable,consisting of a list of directories.syntax of python path is same as that shell variable PATH
   PYTHONPATH from a windows system is 
     set PYTHONPATH=c:\python20\lib;
   PYTHONPATH from a UNIX system is
     set PYTHONPATH=/usr/local/lib/python

dir()-it is a built-in function returns a sorted list of strings containig the names defined by module.
list contains the names of all the modules,variables and functions that are defined in a module
  
 Modes of files:
  to open a file need to use following syntax
    file object = open(file_name[, access_mode][, buffering])
 parameters:
    file_name: Name of the python file that user wants to access.
    access_mode: Mode in which format the file has to be opened,such as read, write, append and so on..this is optional parameter and the 
                 default file access mode is read (r).
    buffering: if the buffering value set to 0, no buffering will takes place 
               if the buffering value is 1, line buffering will be performed while accessing a file
               if the buffering value is specified as an integer greater than 1,then buffering actions will be performed with the indicated buffer size.
               if the buffering value is negative then buffer size is system default 

File object Attributes:
  once file is opened user has one file object,user can get various information related to that file.
  Attributes: 
   1) file.closed: Returns true if file is closed,otherwise false.
   2) file.mode: Returns access mode with which mode file was opened.
   3) file.name: Returns name of the file
   4) file.softspace: Returns flase, if space explicitly required with print,otherwise false.

File Management-Methods:
 There are three methods
   1) Close() :
       Close() method flushes any unwritten information and closes the file object,after that no more writing can be done.
       python automatically closes a file when the refernce of a file is reassigned to another file.
       Ex: 
          fo=open("Hello.py","wb")
          print("Name of the file: ", fo.name)
          fo.close()
       Output:
          Name of the file:  Hello.py
   2) Write() :
       it writes any string to open an file .python strings can have binary data not just text data.
       write() method does not add new line character('\n') to the end of the string.
   3) Read() :
       it reads a string from an open file.This method starts reading from the begining of the file

 Renaming and deleting Files:
  Python OS Module provides methods that help to perform file-processing operations,such as renaming and deleting files.
  To use this module,user needs to import it first and then user can call any related functions.
 Rename() method:
   Syntax: os.rename(current_file_name,new_file_name)
     it has only two arguments that is current file name and new file name   
 Remove() method:
   Syntax: os.remove(file_name)
     it will delete the file by supplying the name of the field to be deleted as the argument
 Directories in python:
  All files are contained with various directories,and python has no problem handeling these too.the os module has several methods that help you create,
  Remove and change directories.
 mkdir() :
   this directory is used to create directories in the current directory.you need to supply an argument to this method which contains the name of the directory to be 
   created.
     Syntax:
      os.mkdir("newdir")
 chdir() :
   this directory is used to change the current directory.it will takes an argument,that was the name of the directory that you want to make the current directory.
     Syntax:
      os.chdir("newdir")
 getcwd() :
   it will show current working directory.
     Syntax:
       os.getcwd()
 rmdir() :
   it delets the directory,which is passed as an argment in the method
   Before removing a directory, all the contents in it should be removed.
     Syntax:
       os.rmdir('dirname')

File & Directories Related methods:
 there are three important sources,which provide a wide range of utility methods to handel and manipulate files & directories on windows and unix operating systems
  File object Methods: The file object provides functions to manipulate files.
  OS Object Methods: This provides methods to process files as well as directories.

     MODULES INSTITUTE:
  *Every python file itself is known as one module.
  *We use modules to break down large amount programs into small manageable and organized files.furthermore,modules provides reusability of code.
  *We can define our most defined functions in a module and we can import it.instead of copying their definations into our programmes.
  *We can access properties of one module into another module by using import statement,we have two types of imports.
    1)Normal import
    2)from import

if we call modules by using import staments it will just import all the definations inside the modules if need to execute thode drfinations,we have to
call explicitly by using of dot(.)operator like below 
 Ex:
    import test
    test.f1
      Note: test is a module name and f1 has function defination,so i imported the test module and called f1 function()
  *Python has a ton of standard modules available,you can check out the full list of python standard modules and what they are for.These files are in the 
   LIB directory inside the location where you installed python. 
  *Standard modules can be imported the same way as we import our user-defined modules.

       1)Normal import:  
       it imports all the modules
       need to call module name or alias name at the time of printing.
      Ex:
         import test    or    import test as t                  #normal import
         test.f1        or    t.f1
       Note:in above example test is renamed as t.this can save us typing time in some cases
    2)from import:
        this method imports the specified part in another module.
        Need to call module (or) alias name at the time of printing.
      Ex:
         from test import a,f1
          Note:above we imported a,f1 function in test module,in this case we don't use the dot(.) operator like below
           Ex:
             from test import a,f1
             a
             f1
      Ex:
         We can import all the definations from a module using following construct.
         from test import *       #import all modules
          Note:Above,we imported all the definations from the test module.This makes all names except those beginning with underscore,visible in our scope 
               importing everything with astreik(*) symbol is not a good programming practice.this can lead to duplicate definations for an identifier.it also
               hampers the readability of our code.

  Python Module search path:
   while importing module,python looks at several places.Interpreter first looks for a built-in module then(if not found) into a list of directories defined in
   sys.path.the search is in this order
       1.Current directory
       2.PYTHONPATH(An environment variable with a list of directory).
       3.The installation-dependent default directory

    Ex:
        import sys
        sys.path
    o/p:
       ['', 'C:\\Program Files\\Python36\\python36.zip', 
       'C:\\Program Files\\Python36\\DLLs',
       'C:\\Program Files\\Python36\\lib',
       'C:\\Program Files\\Python36', 
       'C:\\Program Files\\Python36\\lib\\site-packages']
 
  Note:we can add/modify in this list to add our own path.
    
   Reload Module:
      The python interpreter imports a module only once during a session.this makes things more efficient ,below is the example to show how this works.
      suppose we have code the following code in a module named as "test"
     
      print("Hey Viswa")   -this is the defination inside the test module.
       Now we can see the effet of multiple imports.
      import test
      Hey Viswa
      import test
      import test

  Note:we can see that our code got executed only once,this goes to say that our module was imported only once.
       Now if our module changed during the course of the programme.we would have to reload it.one way to do this is to restart the interpreter,but this 
       doesn't help much.
       Python has neat way of doing this we can use the reload() function inside the imp module to reload a module.this is how its done.
   
      import imp
      import test
      Hey Viswa  --code executed 
      import test
      imp.reload(test)
      Hey Viswa

  The dir() built-in function:

     we can use the dir() function to find out names that are defined inside a module.
     for example we defined a function add(),in the module example that we had in the beginning.
     Ex:
        dir(example)
        
         ['__builtins__',
         '__cached__',
         '__doc__',
         '__file__',
         '__initializing__',
         '__loader__',
         '__name__',
         '__package__',
         'add']

      Note:Above will get sorted list of names (along with add).All other names that begins with underscore are default python attributes associated with the module
           (we did not define them ourself)
   for example the __name__ attribute contains the name of the module.

   import example
   example.__name__
  o/p:
      'example'

 All the names defined in our current namespace can be found out using the dir() function without any arguments.

 a=1
 b="Hello"
 import math
 dir()
o/p:
 ['__builtins__','__doc__','__name__','a','b','math','pyscripter']


-----------------------------------------------------------------------------------------------------------------------
Python provides two very important features to handel any unexpected errors in our python programme and to add debugging capabilities in them
 
 1.Exception Handeling : (here list of standard exceptions available in python)
   An exception is an error occured during execution of the code that distrub's normal flow of the programm instructions.
   when python script raises an exception,it must either handel the exception immediately otherwise it terminates and quits.
     Common Exceptions
        ZeroDivisionError: Occurs when a number is divided by zero.
        NameError: It occurs when a name is not found. It may be local or global.
        IndentationError: If incorrect indentation is given.
        IOError: It occurs when Input Output operation fails.
        EOFError: It occurs when end of the file is reached and yet operations are being performed.
  try-except clause:
   if some suspious code raises an exception put that suspious code in try block after that try block keep except statement followed by block of code which handels
   the problem elegantly as possible.
    Ex1:
      try:
        #our block of code is here that raises an exception.
      except exception1:
        #if there is an exception1 then execute this block.
      except exception2:
        #if there is an exception2 then execute this block.
      except exception3:
        #if there is an exception3 then execute this block.
      except:
        #handel all other exceptions not covered by above except clauses.
      else:
        #If there is no exception then execute this block.
   
 Note:
     1. A single try statement can have multiple except statements,this is used for if try contains statements that may throw different types of exceptions.
     2. We are allowed to provide Generic except clause, Which handels any exception.
     3. After except class we may allowed to use else-clause.the code in the else block executes the code in the try block does not raise an exception.
     4. The else block is a good place for code that does not need the try:block's protection.
  
  try-finally clause:
    we can use finally block along with try block.if we place any code in that finally block that must to be exceuted,whether the try block raised an exception or not.
   Syntax:
    try:
      #our block of code is here that raises an exception.
      #due to exceptions this may be skipped.
    finally:
      #This would always be executed.
    Ex2:
      try:
          a=int(input("enter a valid number:"))
      finally:  
          print("Hi Bro")
  in above example if we enter a number it will print number and then it will print final block code.
  if we enterd a string value in try block code,will get valueerror :invalid literal for int after along with this will get final block code.
  Note:
    the try block must have except or finally block.order must like below
        try->except->else->finally, Where else is optional and occurs if atleast one except apperas.

Arguments of an Exception:
  An exception can have an argument,which is a value that gives more information about the problem.The contents of the arguments vary by exception.
  you can capture an exceptions argument by supplying a variable in the except clause as follows
    try:
        #our block of code is here that raises an exception.
    except ExceptionType, Argument:
        #you can print value of argument here...
   
   If you write the code to handle a single exception, you can have a variable follow the name of the exception in the except statement. 
   If you are trapping multiple exceptions, you can have a variable follow the tuple of the exception.
   This variable receives the value of the exception mostly containing the cause of the exception. 
   The variable can receive a single value or multiple values in the form of a tuple. This tuple usually contains the error string, the error number, and 
   an error location.

 2.Assertions in python:
    Assertion is a sanity check that you can turn on or turn off when you're done with your testing of the program.
    Easiest way to think of an assertion is to liken it to a raise-if statement(or to be more accurate,a raise-if-not statement).An expression is tested,
    and if the result comes out false,an exception is raised.
    we can place assertion at the start of a function to check for valid input, and after a function call to check for valid output.
 The assert statement:
    When it encouters an assert statement,python evalutes the accompanying expression,which is hopefully true.if the expression is false,
    Python raises an AssertionError Exception
     Syntax:
      assert Expression[, Arguments]
     if the assertion fails,python uses ArgumentExpression as the argument for the AssertionError. AssertionError Exception can be caugth and handeled like any
     other exception using the try-except statement,but if not handeled,they will terminate the programme and produce trace-back.
 
--------------------------------------------------------------------------------------------------------------------------------------
Strings in python:

In python strings are "Immutable"
if we need to find any characters in string we will able to use if loop
we can create strings just by enclosing characters in quotes
python treats both single/doubles quotes are same.
python doesn't support character type,those are treated as strings of length one,thus also considered as substring.
for accessing substrings use square brackets [] for slicing below are the examples of strings
Normal strings in Python are stored internally as 	8-bit ASCII, while Unicode strings are stored as 16-bit Unicode.
In python strings are stored as individual characters in a contiguous memory location.
In python we are able to access strings in both directions(Forward and Backward)
Both forward as well as backward indexing are provided using strings in python.
   forward index starts with 0,1,2,3,....
   Backward index starts with -1,-2,-3,-4,... 


Ex1:
str1="hello world"
if "o" in str1:
 print("pora edava")
 else:
 print("wow")

o/p:

pora edava

Ex:it will find in which location substrings are present in main string
   a="Hi bro,how are you"
   b="bro"
   c="are"
   print(a.find(b))
   print(a.find(c))
o/p:
   3
   11
 Note:user is able to write index in place of find it will affect same as above example.


Ex2:
str1="pora labbe"
if str1.find("l") !=5:
 print("yes u'r right)
 else:
 Print("Arey vollu daggara pettukoni chudu")

o/p:

Arey vollu daggara pettukoni chudu

Note:

Above Ex2 we need to use != operation bcz it will search whether the given character is there or not in that location exactly.

-------
we have to split strings equally by using following strategy


Ex1:
str1="Viswamohan Reddy Adutla"
str1=str1.split(" ")
print(str)

o/p:

["Viswamohan","Reddy","Adutla"]

Ex2:
str1="Viswamohan ReddyAdutla"
str=str1.split(" ")
print(str)

o/p:

["Viswamohan","ReddyAdutla"]

Ex3:
str1="Viswamohan Reddy Adutla"
str=str1.split("V")
print(str)

o/p:

['', 'iswamohan Reddy Adutla']

Note:
In the above Ex3 we are giving the condition str=str1.split("V"),so it won't print V and it will give some space instead of that
It will split based on the spaces in the string


If will give some tab in between string it will give more space

Ex1:
str="Viswamohan \t Reddy"
print(str)

o/p:

Viswamohan      Reddy 

Ex2:
str="Viswamohan \t Reddy"
str1=str.split('\t')
print(str1)

o/p:

["Viswamohan","Reddy"]

Note:

if we use escape('\t') character it wont print more spaces

Ex:
a="hi ra"
b="ela unnav ra"
print("a[0]:",a[0])
print("b[0]:",b[7])

o/p:

a[0]: h
b[0]: a

Ex:Slicing of the strings by using [] operator
  a="Hi bro"
  print (a[1])
 o/p:
     i
Ex:range slice it will print values with in that range only [:]
  a="Hi bro"
  print(a[1:5])
o/p:
   i br

Ex:Membership returns true if a letter exists in the string by using in operator
  a="Hi bro"
  print ("i" in a)
o/p:
  True

Ex:Membership returns true if a letter does not exist in string by using not in operator
  a="hi Bro"
  print("i" not in a)
o/p:
  False

Ex:(+) concates the two strings and produces a result
  a="hi bro"
  b="99"
  print(a+b)
o/p:
  hi bro99

Ex:(*) Repeat string 
   a="HiBro"
   b=3
   print(a * b)
o/p:
   HiBroHiBroHiBro

Note: Slice :3 and 0:3 both effects are same

Ex:replace of old string with new string by using of replace() method
  ex1: a="hi bro"
       a.replace("hi bro","How are you")
       print(a)
o/p:
      hi bro
Note:by using above example we didnt replace the value bcz a.replace("hi bro","ekkada unnav") returns a copy of a with replacements mad
     need to use following code to observe change.
  ex2: a="hi bro"
       a=a.replace("hi bro","ekkada unnav")
       print(a)
o/p:
   ekkada unnav
Note:replace method needs atleast two arguments one is old argument which we need to replace and another one is new one. 


Ex:In python we are allowed to change string from upper case to lower case and vice versa.
   a="hi bro"
   print(a.upper())
o/p:
    HI BRO
Ex:if you need to first letter as capital then will use capitalize() method
   a="hi bro"
   print(a.capitalize()
o/p:
   Hi bro
Ex:
   a="HI BRO"
   print(a.lower())
o/p:
   hi bro

join Function:
  this function is used to join any character in to the string 
  below example is to add (:) after each and every character

Ex:
   a="hi bro"
   print(":".join(a))
o/p:
   h:i: :r:a

Reversing Function:
  By using reversing function will able to reverse the string 
Ex:
  a="Hi bro"
  print(''.join(reversed(a)))
o/p:
  orb iH

Updating string:
 Ex:
    a="Hi bro"
    print("updated string:"[:1]+"Ela unnav")
 o/p:
    Hi Ela unnav
Note:whenever you mention the string length it will update the new string after that value.

Count of substrings:it will print how many times the substring is present in the string.
Ex:
   a="Hi bro,How are you"
   b="o"
   print(a.count(b))
o/p:
   3
Ex:to find whether given string is alphanumeric or not
   a="Hi bro"
   b="I am 23 years old"
   print(a.isalnum())
   print(b.isalnum())
o/p:
   False
   True
Ex: to find given string is alphabets or not
  a="Hibro"
  b="Hi bro 24"
  print(a.isalpha())
  print(b.isalpha())
o/p:
  True
  False
Note:Same as above we have isdigit(),islower(),isupper(),isspace(),startswith(),swapcase(),Istrip(),rstrip(),len(string)
   isdigit() : it will check whether do we have digits in our string or not
   islower() : this returns true if all the characters in a string are lowercase letters
   isupper() : this returns true if all the characters in a string are uppercase letters
   isspace() : this return true if characters of a string are whitespaces,otherwise false
   startswith() : This method returns a Boolean value if the string starts with given str between begin and end.
      Ex:
         a="Hello Viswa"
         b="How are you bro"
         print(a.startswith("Hello"))
         print(b.startswith("are",4,7)) 
      o/p:
          True
          True

   swapcase() : It inverts case of all characters in a string.
      Ex: 
         a="Hello Viswa"
         print(a.swapcase())
      o/p:
          hELLO vISWA  
   Istrip() : It removes all leading whitespace of a string and can also be used to remove particular character from leading.
       Ex:
          a="  Hello Viswa"
          b="@@@@How are You"
          print(a.Istrip())
          Print(b.Istrip("@"))
       o/p:
           Hello Viswa
           How are You
  rstrip() : It removes all trailing whitespace of a string and can also be used to remove particular character from trailing.
       Ex:
          a="  Hello Viswa  "
          b="@How are you bro!!!!"
          print(a.rstrip())
          print(b.rstrip("!"))
       o/p:
          Hello Viswa
          @How are you bro
  len(string) : This method returns the length of a string.
     Ex:
        a="Hello Viswa"
        print(len(a))
     o/p:
         11



                    STRING FORMATTING:
 
 Ex1:
    person={'Name':'Viswa','Age':24}
    personal="My Name is {0} and i am {1} yeras old ".format(person['Name'],person['Age'])
    print(personal)

 o/p:
    My Name is Viswa and i am 24 yeras old
 
 Ex2:
     tag="Viswa"
     text="How are you"
     sentance='<{0}><1></{0}>'.format(tag, text)
     print(sentance)
o/p:
     Expected Result
     <Viswa>How are you</Viswa>
     Actual Result
     <Viswa><1></Viswa>

 Ex3:
     person={"Name":"Viswa","Age":24}
     sentance="My Name is " + person["Name"] + " and i am " + str(person["Age"]) + " Years old"
     print(sentance)
 o/p:
     My Name is Viswa and i am 24 Years old

 Ex4:
     person={"Name":"Viswa","Age":24}
     sentance="My Name is {} and i am {} years old".format(person["Name"],person["Age"])
     print(sentance)
 o/p:
    My Name is Viswa and i am 24 years old
 Ex5:
    person=["Viswa",24]
    sentance="My Name is {0[0]} and i am {0[1]} years old".format(person)
    print(sentance)
 o/p:
    My Name is Viswa and i am 24 years old

 Ex6:
     class person():
         def __init__(self,name,age):
             self.name=name
             self.age=age
     p1=person("Viswa",24)
     sentence="My Name is {0.name} and i am {0.age} years old ".format(p1)
     print(sentence)
 o/p:
    My Name is Viswa and i am 24 years old

 Ex7:
    Hello="My name is {name} and i am {age} years old".format(name="Viswa",age='24')
    print(Hello)
 o/p:
    My name is Viswa and i am 24 years old
 
 Ex8:
     for i in range(1,11):
         sentance="The value is {}".format(i)
         print(sentance)
 o/p:
     The value is 1
     The value is 2
     The value is 3
     The value is 4
     The value is 5
     The value is 6
     The value is 7
     The value is 8
     The value is 9
     The value is 10

 Ex9:
    for i in range(1,11):
        sentance="The value is {:02}".format(i)
        print(sentance)
 o/p:
     The value is 01
     The value is 02
     The value is 03
     The value is 04
     The value is 05
     The value is 06
     The value is 07
     The value is 08
     The value is 09
     The value is 10
 Ex10:
      for i in range(1,11):
          sentance="The value is {:03}".format(i)
          print(sentance)
 o/p:
     
     The value is 001
     The value is 002
     The value is 003
     The value is 004
     The value is 005
     The value is 006
     The value is 007
     The value is 008
     The value is 009
     The value is 010
 Ex11:
     pi=3.14534567
     Mirchi="pi is equal to {}".format(pi)
     print(Mirchi)
 o/p:
    pi is equal to 3.14534567
 Ex12:
     pi=3.14534567
     Mirchi="pi is equal to {:.2f}".format(pi)
     print(Mirchi)
 o/p:
    pi is equal to 3.15
 Ex13:
     pi=3.14534567
     Mirchi="pi is equal to {:.5f}".format(pi)
     print(Mirchi)
 o/p:
    pi is equal to 3.14535
 Ex14:
     sentance='1 mb is equal to {:,} bytes'.format(1000**2)
     print(sentance)
 o/p:
    1 mb is equal to 1,000,000 bytes
 Ex15:
     sentance='1 mb is equal to {:,.5f} bytes'.format(1000**2)
     print(sentance)
 o/p:
     1 mb is equal to 1,000,000.00000 bytes
 Ex16:
     import datetime
     mydate=datetime.datetime(2019,1,7,8,42,24)
     print(mydate)
 o/p:
     2019-01-07 08:42:24
 Ex17:
     import datetime
     mydate=datetime.datetime(2019,1,7,8,42,24)
     sentence='{:%B %d,%Y}'.format(mydate)                         # B - Month,d - Date ,Y - Year
     print(sentence)
 o/p:
     January 07,2019
 Ex18:
     import datetime
     mydate=datetime.datetime(2019,1,7,8,42,24)
     sentence='{0:%B %d,%Y} fell on a {0:%A} and was the {0:%j}th day of the year'.format(mydate)          # A - defines day, j- which day it is in that year
     print(sentence)
 o/p:
     January 07,2019 fell on a Monday and was the 007th day of the year



---------------------------------------------------------------------------------------------------------------------------------------------------------
Lists:

Lists are Mutable.

---Diffrence b/w Mutable and Immutable:
     Immutable:once the data is created in the variable it won't allow us to change the data
     Mutable:will allow us to change the data after the creation of variable

List allows us to store the same type of data or different type of date,But each element is divided by comma(,) with in a square brackets []
Use indexes to access the elements inside the List ,Index starts from 0 

Note:
List do not store the elements directly at the index. In fact a reference is stored at each index which subsequently refers to the object stored somewhere in 
the memory. This is due to the fact that some objects may be large enough than other objects and hence they are stored at some other memory location.
Note: 
If start >= end , list[start : end]  will return an empty list. If end specifies a
position which is beyond the end  of the list, Python will use the length of the list for end  instead. 


As per above words python is mutable,So it will allow us to update list values in seques like below

ex1:
list=[10,25,48,56,25]
print [list2]

 o/p:

 48
Update some string in the index of 2 for above list
ex2:
list[2]="Era ela unnav"
print [list2]

 o/p:

 Era ela unnav 

Note:
 Append() and Remove() method will discuss later

Append() method which is used to append i.e., it will add an element at the end of the existing elements.

ex:
 list1=[10,"rahul",'z']  
 print "Elements of List are: "  
 print list1  
 list1.append(10.45)  
 print "List after appending: "  
 print list1

 o/p:
 
 Elements of List are:   
 [10, 'rahul', 'z']  
 List after appending:   
 [10, 'rahul', 'z', 10.45]  


Note: '+'operator implies that both the operands passed must be list else error will be shown.

ex:
 list1=[10,20]  
list1+30  
print list1  

 o/p:
 Traceback (most recent call last):  
        File "C:/Python27/lis.py", line 2, in <module>  
            list1+30  


Python list will allow us to delete values by using del keyword if you know exactly which element(s) you are deleting,if you don't know which element 
you need to delete will use Remove method.

ex3:

list5=[1,2,3,4,5,6]
print[list]

 o/p:

 [1,2,3,4,5,6]

ex4:
list5=[1,2,"Hi",4,5,6]
del list5[2];  or list5.remove("Hi")
print list5       print(list5)

 o/p:

 [1,2,4,5,6]

before deleting the value we have value 3 in index 2 after deleting it the next number will move to index 2 same as above.

Python lists supports lenght,Concatenation,Iteration,Repetition,Membership,Max,Min

cmp(compare):Compare the elements in both the lists

	Explanation: If elements are of the same type, perform the comparison and return the result. If elements are different types, check whether they are numbers.
	If numbers, perform comparison.
	If either element is a number, then the other element is returned.
	Otherwise, types are sorted alphabetically .
	If we reached the end of one of the lists, the longer list is "larger." If both list are same it returns 0.

ex:		
  list1=[101,981,'abcd','xyz','m']  
  list2=['aman','shekhar',100.45,98.2]  
  list3=[101,981,'abcd','xyz','m']  
  print cmp(list1,list2)  
  print cmp(list2,list1)  
  print cmp(list3,list1)

o/p:

  -1  
  1  
  0  

  

len(length) :Gives total length of the list 
max         :Gives max value of the list 
min         :Gives min value of the list 
list(seq)   :Convert tuple into list (I am not sure)
Count       :Returns count how many times obj occurs in list 

	ex:

		syntax:
   			varaiablename.count(object)


append      :Append object obj list  
pop         :Removes and returns last object or obj from list
reverse     :Reverse object of list in place 
   ex:
      list5=[1,2,"hi",4,5,6]
      list5.reverse()
      print(list5)
o/p:
     [6, 5, 4, 'hi', 2, 1]

sort:sort object of list,Use compare func if given 
   ex:
       syntax:
           varaibaletype.sort()
   Ex:
      list=[17,676,89,675,987,98,900]
      list.sort()
      print(list)
  o/p:
     [17, 89, 98, 675, 676, 900, 987]


index :It returns the index value of the object.

ex:
 
 data = [786,'abc','a',123.5]  
 print "Index of 123.5:", data.index(123.5)  
 print "Index of a is", data.index('a')   

o/p:
 
 Index of 123.5 : 3  
 Index of a is 2  

insert     :python will allow us to insert element in the list based on the index

    ex:
       syntax:
	 variabletype.insert(2,"Hello")
   here the insert condition insert the value Hello in second position

list extend(Sequence) Method:
Ex:
   data1=['abc',123,10.5,'a']  
   data2=['ram',541]  
   data1.extend(data2)  
   print data1  
   print data2  
o/p:
    ['abc', 123, 10.5, 'a', 'ram', 541]  
    ['ram', 541]

  

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Tuples:

Tuples are immutable
differnce between tuples and lists is tuples cannot be changed unlike lists and use parantheses,whereas list uses square brackets.
Python has tuple assignment feature which enables you to assign more than one variable at a time.
Any set of multiple objects, comma-separated, written without identifying symbols, i.e., brackets for lists, parentheses for tuples, etc., default to tuples 

Ex:
  print ("Hi","Ekkada unnav",78,98,"eppudu vachav")
o/p:
  Hi Ekkada unnav 78 98 eppudu vachav

Ex:  Python empty set
  tup=()
  print(tup)
o/p:
  ()
  

Ex:
tuple1=("Hello",3,"Viswamohan",9,"Reddy",8);
tuple2=();
tuple3=(50,);

The empty tuple is written as two parentheses containing nothing(tuple2)
To write a tuple containing a single value you have to include a comma, even though there is only one value(tuple3)_--But it is working without use comma also need to 
invistigate

Python tuples will allow us to access values,Slicing and all by using of square brackets.

Ex1:
  tuple1=("Hello",6,9,"Em chestunnav ra");
  print tuple1[1]

 o/p:
  
  6   

Ex2:
  tuple2=("hello",6,8,10.654);
  print tuple2[1:]
 
  o/p:
  
   6,8,10.654

Tuples are immutable so that you are not allowed to add the values in existing tuple but you are able to take portion of existing tuples to create new tuple

Ex3:
    tup1=(5,8,9,"Rebel");
    tup2=(79,67,10.87,"Mirchi");
    tup3=tup1+tup2;
    print tup3

o/p:
  (5, 8, 9, 'Rebel', 79, 67, 10.87, 'Mirchi')

Ex:
     tuple1=("Hi",78,96)
     tuple2="hello",76,98
     print(tuple1)
     print(tuple2)
o/p:
      
    ('Hi', 78, 96)
    ('hello', 76, 98)

Note:If Parenthesis is not given with a sequence, it is by default treated as Tuple. (tuple2)


in python tuples Removing of individual element is not possible but will allows us to delete entire tuple by using del keyword. 

Packing and unpacking tuples:

Packing tuples is nothing but we place value into a new tuple
  
  Ex4:
    tup1=(5,8,90,"hello")
while unpacking is nothing but we extract those values back into varaibles

  Ex5:
     (5,8,3,"viswa")=tup1

  Ex6:
	x = ("Guru99", 20, "Education")  #tuple Packing
	(company, emp, profile) = x      #tuple Unpacking
	print(company)
	print(emp)
	print(profile)
   o/p:
	Guru99
	20
	Education


Tuples supports comparison operator
 
  Ex6:

    tup1=(6,8,8)
    tup2=(6,8,9)
    if tup1>tup2:
      print("tup1 is bigg")
    else:
      print("tup2 is bigg")

  o/p:

    tup2 is bigg

using tuples as keys in dictinioary:

Since tuples are hashable, and list is not, we must use tuple as the key if we need to create a composite key to use in a dictionary. 
  Example: We would come across a composite key if we need to create a telephone directory that maps, first-name, last-name, pairs of telephone numbers, etc. 
  Assuming that we have declared the variables as last and first number, we could write a dictionary assignment statement as shown below: 
       directory[last,first] = number
Inside the brackets, the expression is a tuple. We could use tuple assignment in a for loop to navigate this dictionary. 
       for last, first in directory:
       print first, last, directory[last, first]
This loop navigates the keys in the directory, which are tuples. It assigns the elements of each tuple to last and first and then prints the name 
and corresponding telephone number. 

Built-in functions with Tuple:

To perform different task, tuple allows you to use many built-in functions like all(), any(), enumerate(), max(), min(), sorted(), len(), tuple(), etc. 

Advantages of tuple over list:

Processing of Tuples are faster than Lists,Bcz tuples are Immutable. 
Tuples that consist of immutable elements can be used as key for dictionary, which is not possible with list
If you have data that is immutable, implementing it as tuple will guarantee that it remains write-protected

Nested tuples:

Python will allows us to pass tuple as an element to create a new tuple.like below

Ex7:
       tuple1="hi","Mirchi",19,87.98
       tuple2=tuple1,(78,45,'Darling')
       print(tuple1)
       print(tuple2)
o/p:
       
      ('hi', 'Mirchi', 19, 87.98)
      (('hi', 'Mirchi', 19, 87.98), (78, 45, 'Darling'))

if we write sequence in some other format and will able to convert it to tuple like below

Ex8:
       Mirchi=["Hi",10,98.45]
       Mirchi=tuple(Mirchi)
       print(Mirchi)
o/p:
       ("Hi",10,98.45)

in above example Sequence Mirchi looks like List but in below step will convert it into tuple like type casting. 

Ex9:
     Mirchi=["Hi",10,98.45]
     Mirchiiii=tuple(Mirchi)
     print(Mirchi)
o/p:
     ["Hi",10,98.45]

observe the difference b/w ex8 and ex9,here i printed Mirchi so that is printed in List Format. 

Python Tuple of Tuples:
    Tuples can also be nested, it means we can pass tuple as an element to create a new tuple. 
    See, the following example in which we have created a tuple that contains tuples an the object.
Ex:
    tupl1='a','mahesh',10.56  
    tupl2=tupl1,(10,20,30)  
    print tupl1  
    print tupl2 
o/p:
    ('a', 'mahesh', 10.56)  
    (('a', 'mahesh', 10.56), (10, 20, 30)) 

Uses of tuples:
1.Process of tuples are faster than list.
2.it makes the data safe as tuples are immutable and hence cannot be changed.
3.Tuples are used for string formatting. 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Python Dictionary's:

Dictionary is mutable i.e., value can be updated.
Python Dictionary are defined into two elements Keys and Values.
Keys will be a single element values can be a list or list within a list, numbers, etc
Each key is seperated from it value by Colon (:) and the item are seperated by commas (,)
Key must be unique and immutable (No Duplicate key is allowed). Value is accessed by key. Value can be updated while key cannot be changed.if we enter duplicate keys
 (or)same keys the last key will win means last key will execute while running the code.
if need to give duplicate key use tuples or lists like below
 ex:
    a={["Name"]:"Viswa","age":28}
   here i used list []
in Dictionary keys are case-sensitive - same key name but different case are treated as different keys in python dictionaries.
Dictionary's are enclosed by curley bases {}
Dictionary is an unordered set of key and value pair.
Ex1:
 dict={"Name":"Viswa","Age":23,"Birtday":16-02-1995}
In above Ex1 Name is the key and Viswa is the Element like Age and birthday are keys and 23,16-02-1995 are the elements for those keys 
The values of a dictionary can be of any type, but the keys must be of an immutable data type such as strings, numbers, or tuples. 
Dictionary is known as Associative array since the Key works as Index and they are decided by the user.

Ex2:
   dict={"Viswa":23,"Madhu":24,"Baba":45,"Surya":33}
   print(dict["Baba"])
o/p:
   45

Copying Dictionary:
  Ex3:
       Boys = {'Tim': 18,'Charlie':12,'Robert':25}
       Girls = {'Tiffany':22}	
       studentX=Boys.copy()
       studentY=Girls.copy()
       print studentX 
       print studentY
 o/p:
       {'Tim': 18, 'Charlie': 12, 'Robert': 25}
       {'Tiffany': 22}   

Above example boys and girls are two dictionaries and studentX and studentY are new dictionaries and i just copied the same data from boys and girls by using of Copy
method.

Updating and Deleting key value pairs in existing Dictionary:

Update:
 Python dictinarys will allows us to update the key-value pairs in existing dictionary by using update command
  Ex4:
      Dict1={"Viswa":23,"Baba":45}
      Dict1.update({"Madhu":25})
      print(Dict1) 
  o/p:
      {'Viswa': 23, 'Baba': 45, 'Madhu': 25}

Deletion:
  Python dictinarys will allows us to delete the key-value pairs in existing dictionary by using del command
   Ex5:
       Dict1={"Viswa":23,"Raghu":65,"Madhu":33}
       del Dict1["Madhu"]
       print(Dict1)
   o/p:
       {'Viswa':23,'Raghu':65}

   Ex6:
       data={"Viswa":23,"Madhu":45}
       print(len(data))      ----Prints length of the dictionary
   o/p:
       2
   Ex7:
       data={"Viswa":23,"Madhu":45}
       print(str(data))
   o/p:
       {'Viswa': 23, 'Madhu': 45}
This str command produces a printable string representation of a dictionary
   
  Ex8:
      data={"Viswa":23,"Madhu":34,"Baba":45}         
      print (data.keys())       ----Print keys in that dictionary
  o/p:
      dict_keys(['Viswa', 'Madhu', 'Baba'])
  Ex9:
      data={"Viswa":23,"Madhu":34,"Baba":45}
      print (data.values())     ----Print Values in that dictionary
  o/p:
      dict_values([23, 34, 45])
  Ex10:
      data={"Viswa":23,"Madhu":34,"Baba":45}
      print(data.items())   ----print each key and value pairs separately
  o/p:
      dict_items([('Viswa', 23), ('Madhu', 34), ('Baba', 45)])
      
  Ex11:
       data={"Viswa":23,"Madhu":34,"Baba":45}
       print(data.clear())      ----Print None
       Print(data)              ----Print {}
  o/p:
       None
       {}

  Ex12:
      data={"Viswa":23,"Madhu":34,"Baba":45}
      print(data.has_key("Madhu"))  ----It returns a boolean value. True in case if key is present in the dictionary, else false.
      print(data.has_key("good"))     
 o/p:
      True
      False
 Ex13:
     data={"Viswa":23,"Madhu":34,"Baba":45}
     print(data.get("Viswa"))         ---This method returns the value of the given key. If key is not present it returns none.
     print(data.get("Ashok"))
 o/p:
    23
    None
 Ex14:
     data={"Viswa":23,"Madhu":34,"Baba":45}
     data1={}
     data2={}
     data1=data1.fromkeys(data)
     print(data1)
     data2=data2.fromkeys(data,43)
     print(data2)
 o/p:
     {'Viswa': None, 'Madhu': None, 'Baba': None}
     {'Viswa': 43, 'Madhu': 43, 'Baba': 43}

Above Example i.e., Ex14 it is used to create a new dictionary from the sequence where sequence elemets forms the key and all keys share the same value,
in case value is not given it sets the value of keys to be none 

Note:it will work even didn't mention data1 and data2 dictionaries in above example

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Functions:

A functions in python are utilized to the code in more than one place in a programme,Sometimes is called as method or procedure.
Functions provides better modularity of you'r programme and high degree of code reusability.
Python provides number of built in functions like print() etc.,apart from this you can also create you'r own functions these functions are called as
User-defined functions.

Types of Functions:
  1.Built-in functions
                      functions that are already available in python libraries  --To get those functions type this  --  dir(__builtins__)
  2.User-defined functions
                      functions that are created by programmer to meet the requirements.

Defining function:
  1.Keyword def is used to start and declare a function. def specifies the starting of function block
  2.def is followed by function name and parenthesis.
  3.Parameters are passed inside the parenthesis. At the end a colon is marked.
  4.Python code requires indentation (space) of code to keep it associate to the declared block.
     if we didn't give any indentation(space) it will rise an errors example below
        Ex:
            data={"Viswa":23,"Baba":67,"Surya":99}
            print(data)
            o/p:
                if will write like this it will raise indent errors so to avaoid those errors give indentation like below
       Ex:
          data={"Viswa":23}
             Print(data)
      o/p:
          now will get expected output
      Note:Maintain atleast 3-4 indents(Spaces) and use same number of indents in entire programme otherwise it will raise 
           "unindent does not match any other indentation level"
  5.The first statement of a function can be an optional statement - the documentation string of the function or docstring.

Syntax:
   def function_name(Parameters):

to execute a function it needs to be called.This is called as Function calling.

  Ex:
      def sum(a,b)
def -define the function name
sum -function name
a,b - those are parameters passed inside the paranthases 

                           (Pending)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Python Files (input/output):

Python provides us to methods to read and write the data.
python also provides support of reading and writing data to Files.
in python will use print() function to print the values.

Inputs from a keyboard:
 1.input()
 2.raw_input()

1.input():
   this function is used to take the values from the user.whatever expression is given by the user,it is evaluted and returned back.

Ex:
   a=input("Enter the values")
   print("Enterd values is:",n)
o/p:
   Enter the values 25*3
   Enterd values is 75

2.raw_input():
    function is used to take input from the user. It takes the input from the Standard input in the form of a string and reads the data from a line at once.
Note:Whatever the input provided by user it will consider that as string i.e.,if user enter input as 10 so python automatically allocate the variable as int,
     if we use raw_input then it will consider as string for that '10' like all the values

Ex:
   n=raw_input("Enter your name ");  
   print("Welcome :",n)
o/p:
   Enter your name Viswa
   Welcome:Viswa

Note:NameError: name 'raw_input' is not defined (I am getting these error when i am trying to run this code)

Note:
 raw_input() function returns a string. Hence in case an expression is to be evaluated, then it has to be type casted to its following data type. 

Ex:
  if you need to enter int,float values etc..then use query like below
   name=int(raw_input("Enter you'r name")
   sal=float(raw_input("Enter you'r salary")
   age=int(raw_input("Enter you'r age")
   print("Welcome",name "You'r salary",sal "You'r age is",age)

Above examples are not getting output.

Python file handeling:

Python provides the facility of working on files.A file is external storage on hard disk from where data can be stored and retrived.
Operations on files:
1.Opening a file:
 before working on files you need to open file first.
 to open a file, python built in function open() is used It returns an object of File which is used with other functions. 
 Having opened the file now you can perform read, write, etc. operations on the File. 
syntax:
obj=open(filename , mode , buffer)   
 filename : it is the name of the file
 mode:It specifies the mode in which File is to be opened.
      There are many types of mode. Mode depends the operation to be performed on File. Default access mode is read. 
2.Closing a File:
  Once you are finished with the operations on File at the end you need to close the file. It is done by the close() method. 
  close() method is used to close a File.
Syntax:
fileobject.close()   
3.Writing to a File:
  write() method is used to write a string into a file.

Syntax:
fileobject.write(string str)  
4. Reading from a File:
  read() method is used to read data from the File.python strings can have binary data.apart from text data.
Syntax:
fileobject.read(value)
here, value is the number of bytes to be read. In case, no value is given it reads till end of file is reached.

Attributes of files:
1.Name:it returns the name of the file
2.Mode:returns mode in which file is being opened
3.Closed:Returns Boolean value. True, in case if file is closed else false.

Modes of files:
two types
1.Text
2.Binary

r   -reading mode
r+  -read and write
rb  -reading in binary format it is default mode 
rb+ -read and write in binary format 
w   -writing mode,if file is already opened it overwrite the file else create new file
w+  -read and write mode if alreay opened it overwrites the file else creates new file 
wb  -writing in binary format If file already exists, then overwrite the file else create a new file.
wb+ -read and write in binary format If file already exists, then overwrite the file else create a new file.
a   -opens file in appending mode If file already exists, then overwrite the file else create a new file.
ab  -open file in appending mode in binary format If file already exists, then overwrite the file else create a new file.
a+  -open file in reading and appending mode If file already exists, then overwrite the file else create a new file.
ab+ -open file in reading and appending mode for binary format If file already exists, then overwrite the file else create a new file.
 
Methods:

There is a module "os" defined in Python that provides various functions which are used to perform various operations on Files. 
To use these functions 'os' needs to be imported.

1.rename()
  It is used to rename a file. It takes two arguments, existing_file_name and new_file_name.
Syntax:
  import os  
  os.rename('mno.txt','pqr.txt') 
2.remove()
  It is used to delete a file. It takes one argument. Pass the name of the file which is to be deleted as the argument of method.
Syntax:
import os  
os.remove('mno.txt' 
3.mkdir()
  It is used to create a directory. A directory contains the files. It takes one argument which is the name of the directory. 
Syntax:
import os  
os.mkdir("new") 
4.chdir()
  It is used to change the current working directory. It takes one argument which is the name of the directory.
Syntax:
import os  
os.chdir("new")  
5.getcwd()
  It gives the current working directory.
Syntax:
import os  
print os.getcwd() 
6.rmdir()
  It is used to delete a directory. It takes one argument which is the name of the directory.we need to give full directory name,otherwise it will search the directory
  in current directory.Before removing a directory, all the contents in it should be removed
Syntax:
import os  
os.rmdir("new") 
7.tell()
  It is used to get the exact position in the file.
Difference b/w raw_input and input:
 raw_input read one line at a time from standard input and returns it as string (removing the trailing newline).
 input is equal to raw_input except that it assumes the input is a valid python expression and returns the evaluated result to you.
8.seek():
 it will skip the character whatever we enter after that it will print the data
9.readlines():
  it will read each and every line seperately,finally all the strings stored into a list object.
10.Pickling method:
  it has some functions,by using of that will convert our python object to some other format (text...,)
11.With:
  with is a operator file will close automatically when cursor comes out from with operator.
 
Files&Directories:
File Object Methods: The file object provides functions to manipulate files.
OS Object Methods: This provides methods to process files as well as directories. 




             FILE I/O:
 

 To perform any operation on the files need to open by using open keyword. like below

 f=open("test.py","r")
      or
 with open('test.py','r') as f:          ---it is some what difficult

 print(f.name)
 f.close()

Advantage of with open command:
 
 with open("test.py","r") as f:
   
  Note:1)we have to work within the block of the code once we write the code outside of the block it wont perform those operations,it will close the file once 
         you come out from the block eventhough you didnt mention to close the file. 
       2)it will also close the file if it throws any error.
Ex:
with open("test.txt","r") as f:
    f_contents=f.read()
    print(f_contents)
o/p:
  it will print entire data of the file
Ex:
with open("test.txt","r") as f:
    f_contents=f.readlines()
    print(f_contents)
o/p:
   it will show entire data in continous string type
Ex:
with open("test.txt","r") as f:
    f_contents=f.readlines()
    print(f_contents)
 
    
    f_contents=f.readlines()
    print(f_contents)

o/p:
    it will print first and second line after first line will get one empty line or empty space.
Ex:
with open("test.txt","r") as f:
    f_contents=f.readlines()
    print(f_contents,end="")

    
    f_contents=f.readlines()
    print(f_contents,end="")

o/p:
   it will print first and second line without any empty space or empty line. 

Ex:
with open("test.txt","r") as f:
    for line in f:
        print(line,end="")
o/p:
   Here it will print the entire data of the file line by line because here we used for loop it will iterate the loop until data gets executed.
Ex:
with open("test.txt","r") as f:
    f_contents=f.read(100)
    print(f_contents)
  
    f_contents=f.read(100)
    print(f_contents)
o/p:
   for first print statement we passed an argument 100 so it will print first 100 characters of the file,if we run the same query second time it will print next 
   100 characters ,if we run same query it will print next 100 characters if all data is executed it will just terminate our programme.

Above techinque is used to read data from large files.

while opening any file it will check the file wheather it is available or not if it is available it will open the file,if not it will create the new file with that
what we gave it to open,if we are not sure wheather file is there or not so you can use "a"(append) mode so it will append the data whatever will write if the file 
exists already.







 



------------------------------------------------------------------------------------------------------------------------------------------------------------
Python adds the boolean values
Ex1:
   x=True
   y=False
   print(x+y)
o/p:
   1
Ex2:
   x=True
   y=True
   print(x+y)
o/p:
   2
To know the type of the value use type function 
Ex3:
   print type("Hello World")
   print type(6)
   print type(8.3)
   print type(True)
o/p:
   <type 'str'>
   <type 'int'>
   <type 'float'>
   <type 'Bool'>
Ex4:
    a=100
    b=200
    print(a+b)
o/p:
    300
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Python OOPs:

 OOP's Terminologies:
   Class:
         User defined prototype for an object that defines a set of attributes that characterize any object of the class
         Attributes are data members (class variables and instance variables) and methods,accessed via dot notation.
         Syntax:
                Class Emp:             #here emp is class name,class name always starts with Capital letter
                Class EmpId:           #if class name is two words string need to write like this
  Class variable:
         A Variable that is shared by all instance of a class.class variables are defined within a class but outside any of the class's methods.
         class variables are not used as frequently as instance variables are.
  Data member:
         A class cariable or instance variable that holds data associated with a class and its objects.
  Function Overloading:
         The assignments of more than one behaviour to a particular function.The operation performed varies by the types of objects(arguments) involved.
  Instance variables:
         A variable that is defined inside a method and belongs only to the current instance of a class.
  Inheritance:
         it will share the properties/behaviours of parent class to child class.
  Instance:
         An individual object a certain class.An object obj that belongs to a class circle.
  instantiation:
         The creation of an instance of a class.
  Method:
         A special kind of function that is defined in a class defination.
  Object:
         A unique instance of a data structure that is defined by its class.An object compramise both data members(class variables and instance variables)
         and methods.
  operator overloading:
         The assignment of more than one function to a particular operator.

  Ex:
     Class Employee:
     empcount=0
     def __init__(self,name,salary):
         self.name = name
         self.salary = salary
         Employee.empcount += 1
     def displayCount(self):
          print("Total Employee %d",Employee.empCount)
     def displayEmployee(self):
          print("Name : ", self.name, ", Salary: ", self.salary)
 Note:
     Class Name : Employee
     Constructor : __init__
     Instance variables : name, salary
     To access instance variables: self.instancevar
     classvariable : empcount
     To access class variables : classname.classvar
     Methods : displayCount, displayEmployee

  Creating Instance Objects:
   To create instance of a class,one must call the class using class name and pass in whatever the arguments the __init__ method accept excepts self.
  Accessing Attributes:
   user can access the object attributes using dot operator with object.class variables would be accessed using class name 
    example:
      emp1.displayEmployee()
  Note:User can able to add,remove or modify attributes of a classes and objects at any time.
     Ex:emp1.age = 7 # Add an 'age' attribute
        emp1.age = 8 # Modify 'age' attribute
        del emp1.age # Delete age attribute
 Method Attribute:
    Methods may call other methods by using method attributes of the self argument.
    Ex:
      Class Bag:
          def __init__(self):
              self.data = []
          def add(self, x):
              self.data.append(x)
          def addtwice(self, x):
              self.add(x)
              self.add(x)
 We can use functions to access attributes instead of normal statements to access attributes.

 Constructors:
   The base class constructor will not get called automatically whenever a child object is created.it needs to be called explicitly using super().__init__().
    Ex:
        class Child(Base):
            def	__init__(self, value, something_else):
                super().__init__(value)
                self.something_else = something_else
 issubclass() or isinstance() Functions:
    user can use issubclass() or isinstance() functions to check relashionship of two classes and instances.
     issubclass() Function:
       The issubclass(sub, sup) boolean function returns true if the given subclass sub is indeed a subclass of the superclass sup.
     isinstance() Function:
       The isinstance(obj, Class) boolean function returns true,if object is an instance of class or is an instance of subclass of class.
      
  Overriding Methods:
    Derived classes may override methods of their base classes by providing a new defination for the same method that exists in the base class.
     Ex:
         class Parent:
             def myMethod(self):
                 print("calling parent method")
         class Child(Parent):
             def myMethod(self):
                 print("Calling child method")
         c=Child()
         c.myMethod()
  output:
         Calling child method

  Data Hiding:
    An object attribute may or may not visible outside of the class defination.for these cases user can name attributes with a 
    double underscore prefix and those attributes will not be directy visible to outsiders.(Private variables)


it is object oriented programming language,it allows us to develop an application using object oriented approach
in python we can easily create and use classes and objects.

Major principles of object-oriented programing systems are
1.Object
2.Class
3.Method
4.Inheritance
5.Polymorphism
6.Data Abstraction
7.Encapsulation

1.Object:
object is an entity that has state and behaviour.
it may be anything (Physical and Logical)
object is physical entity representing memory
 ex:Mouse,apple,pen,Mobile.

2.Class:
Class is a logical entity contains logics of the application 
class can be defined as collection of objects,object is simply collection of data(Variables) and methods (Functions).
 Ex:Consider employee is a class then it should contains attributes and methods i.e.,email id,sal,age,dob,name etc..,
Class is a blueprint of the object.Without class there is no object.
We are able to create multiple objects by using of single class but every object takes memory.
an object is also called as instance of a class and the process of creating this object is known as instantiation.
Python class is a mixture of class mechanism of C++ and Modula-3.
 
Class is defined by using keyword class

Note:
In python 2.7 we are not able to extend the class {it is not default child class of object}-there is a function to check whether it is child class of object or not
i.e.., issubclass()
In python 3.0 class is by default child class of object 

we have three types of class declarations in python 3.0
1.class MyClass:
2.class MyClass():
3.class MyClass(object):

if you need to create class without giving any logics then follow below
class MyClass():
  pass  (pass - represents empty body in the class)

in class we are able to declare 
Variables
Functions
Constructor__init__()
__str__()
__del__()

Note:Examples of declaring variables and functions inside the class
ratan 2nd video of class concept

(pending)


------------------------------------------------------------------------------------------------------------------------------------------------------

Date & Time:
 Python provides time package to deal with date and time.
 it helps to retrieve current date and time and manipulation using built-in methods.

Tick:
  Time intervals are floating-point numbers in units of seconds.
  Particular instants in time are expressed in seconds since 12:00am, January 1, 1970(epoch).

Retrieve Time:
  To retrieve current time,python provides pre-defined function localtime(),it receives a parameter time.time()
  here time is a module and time() is a function that returns a current system time in number of ticks since 12:00 am,January 1,1970.
  it is known as epoch.
  Tick is simply a floating point number in seconds since epoch.
Ex1:
   import time
   tick=time.time()
   print("Number of ticks since 12am,January 1,1970:",ticks)
o/p:
   Number of ticks since 12am,January 1,1970: 1538407548.7132769

Note:In above example we mentioned the Number of ticks since january 1970 so it printed some large floating point value.

Ex2:  (Getting Current time)
   import time
   localtime=time.localtime(time.time())
   print("Current time is:",localtime)
o/p:
   Current time is: time.struct_time(tm_year=2018, tm_mon=10, tm_mday=1, tm_hour=23, tm_min=12, tm_sec=42, tm_wday=0, tm_yday=274, tm_isdst=0)



TimeTuple?:

  Many of python's time functions handle time as a tuple of 9 numbers,as below
   Index       Field                           Values
     0          4-digit year                    2008
     1          Month                           1 to 12
     2          Day                             1 to 31
     3          Hour                            0 to 23
     4          Minute                          0 to 59
     5          Second                          0 to 61 (60 or 61 are leap-seconds)
     6          Day of Week                     0 to 6 (0 is monday)
     7          Day of year                     1 to 366 (Julian day)
     8          Daylight savings                -1,0,1, -1 menas library determines DST

  Above tuple is eqivalent to struct_time structure.This structure has following attributes-
   Index      Attributes                       Values
     0         tm_year                          2008         
     1         tm_mon                           1 to 12 
     2         tm_mday                          1 to 31
     3         tm_hour                          0 to 23
     4         tm_min                           0 to 59 
     5         tm_sec                           0 to 61 (60 or 61 are  leap-seconds)
     6         tm_wday                          0 to 6 (0 is Monday)
     7         tm_yday                          1 to 366 (Julian day)
     8         tm_isdst                         -1,0,1,  -1 means library determines DST.

Python formatted time:
  Python supports formatted time as well means simple method to get time in readable format is asctime()
    1. Pass the time structure in a predefined function asctime().It is a function defined in time module.
    2. It returns a formatted time which includes Day,month,date,time and year.
    3. Print the formatted time.
Ex:
  import time
  localtime=time.asctime(time.localtime(time.time()))
  print(localtime)
o/p:
  Mon Oct  1 23:22:36 2018
   
     or
Ex:
   import time
   localtime=time.asctime(time.localtime(time.time()))
   print("Current local time is:",localtime)
o/p:
   Current local time is: Mon Oct  1 23:29:26 2018

Python Calender:
  Python provides calender module to display calender.
  This module will gives wide range of methods to play with yearly and monthly calender

Ex: 
   import calendar
   cal=calendar.month(2018,2)
   print("Requested calendar month is:",cal)
o/p:
   Requested calendar month is:    February 2018
   Mo Tu We Th Fr Sa Su
            1  2  3  4
   5  6  7  8  9 10 11
  12 13 14 15 16 17 18
  19 20 21 22 23 24 25
  26 27 28

Python Time Module Methods:
  Time module provide us lot of built-in functions which are used to work with time.
   Methods:
     time():
            it returns floating point value in seconds since epoch i.e., 12:00 am,January 1, 1970
     asctime(time):
            it takes the tuple returned by localtime() as parameter.it return a 24 character string.
     sleep(time):
            The execution will be stopped for the given interval of time.
     strptime(string,format):
            it returns an tuple with 9 time attributes.it receives an string of date and a format.
     gmtime()/gmtime(sec):
            it return struct_time which contains 9 time attributes.In case seconds are not specified it takes current second from epoch.
     mktime():
            it returns second in floating point since epoch.
     strftime(format)/strftime(format,time):
            it returns time in particular format.if time is not given,current time in seconds is fetched.

 Python time() Method:
   it is used to get current time using python script.
   Ex:
      import time
      print(time.time())
  o/p:
      1538565784.4489133
 Python asctime(time) method:
   it is used to return 24 character date time string using python script.
   Ex:
      import time
      A=time.asctime(time.localtime())
      print("Exact time is:",A)
  o/p:
      Exact time is: Wed Oct  3 16:59:41 2018
 Python sleep(time) Method:
   it is used to stop the execution of script for the given interval of time.
   Ex1:
      import time
      localtime=time.asctime(time.localtime(time.time()))
      print(localtime)
      time.sleep(10)
      localtime=time.asctime(time.localtime(time.time()))
      print(localtime)
  o/p:
      Wed Oct  3 17:08:23 2018
      Wed Oct  3 17:08:33 2018
   Ex2:
      import time
      localtime=time.asctime(time.localtime(time.time()))
      print(localtime)
      time.sleep(10)
      print(localtime)
  o/p:
     Wed Oct  3 17:10:39 2018
     Wed Oct  3 17:10:39 2018
Note:In both the examples the second output line prints after 10 seconds but in ex2 second output line same as first output line bcz here we skip the localtime line.

 Python strptime(string str,format f) method:
   it returns an tuple with 9 time's attributes.it receives string of date and a format.
   Ex:
      import time
      Required time=time.strptime("16 Feb 95","%d %b %y")
      print(Required time)
  o/p:
      time.struct_time(tm_year=1995, tm_mon=2, tm_mday=16, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=47, tm_isdst=-1)

Note:
     the strptime() takes a string and format as an arguments.The format refers to string passed as an argument. 
     "%a %b %d %H:%M:%S %Y" -- These are the default directivies.(we have many directivies which can be used)
       
      %a  --Weekday name
      %b  --month name
      %c  --date and time
      %d  --date
      %e  --day of a month 
      %m  --month in digit
      %n  --new line character
      %s  --second
      %t  --tab character

 Python gmtime() Method:
   it returns struct_time which contains 9 time attributes.in case,seconds are not specified it takes current second from epoch.
   Ex:
      import time
      print(time.gmtime())
   o/p:
       time.struct_time(tm_year=2018, tm_mon=10, tm_mday=3, tm_hour=13, tm_min=46, tm_sec=47, tm_wday=2, tm_yday=276, tm_isdst=0)
  
 Python mktime() Method:
   it returns second in floating point since epoch.
   Ex:
      import time
      t=(2014,2,17,17,3,38,1,48,0)
      second=time.mktime(t)
      print(second)
  o/p:
      1392636818.0
  
 Python strftime() Method:
   it returns time in particular format.if time is not given,current time in seconds is fetched.
   Ex:
      import time
      t=(2014,6,26,17,3,38,1,48,0)
      t=time.mktime(t)
      print(time.strftime("%b %d %y %H:%M:%S",time.gmtime(t))) 
  o/p:
      Jun 26 14 11:33:38

Note:Not in clear on above two methods.

 time.clock() method:
    it returns current CPU time as floating point number of seconds.
    to measure computational costs of different approaches,the value of time.clock is more useful than the time.time() method
 Ex:
    import time
    print(time.clock())
 o/p:
     3.2073990848007454e-07
 
 time.ctime([secs]) Method:
   Like asctime(localtime(secs)) and without arguments is like asctime( ).
   Ex:
      import time
      print(time.ctime())
  o/p:
      Wed Oct  3 19:56:19 2018
 time.tzset() Method:
   Resets the time conversion rules used by the library routines. The environment variable TZ specifies how this is done.

 Pthon Calendar module:
   calendar module provides many functions and methods to work on calendar,list of methods are given below:
   prcal(year)                 :it prints the whole calendar of the year.
    Ex:
       import calendar
       print(calendar.prcal(1995))
    o/p:
                             1995

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                   1             1  2  3  4  5             1  2  3  4  5
 2  3  4  5  6  7  8       6  7  8  9 10 11 12       6  7  8  9 10 11 12
 9 10 11 12 13 14 15      13 14 15 16 17 18 19      13 14 15 16 17 18 19
16 17 18 19 20 21 22      20 21 22 23 24 25 26      20 21 22 23 24 25 26
23 24 25 26 27 28 29      27 28                     27 28 29 30 31
30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2       1  2  3  4  5  6  7                1  2  3  4
 3  4  5  6  7  8  9       8  9 10 11 12 13 14       5  6  7  8  9 10 11
10 11 12 13 14 15 16      15 16 17 18 19 20 21      12 13 14 15 16 17 18
17 18 19 20 21 22 23      22 23 24 25 26 27 28      19 20 21 22 23 24 25
24 25 26 27 28 29 30      29 30 31                  26 27 28 29 30

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2          1  2  3  4  5  6                   1  2  3
 3  4  5  6  7  8  9       7  8  9 10 11 12 13       4  5  6  7  8  9 10
10 11 12 13 14 15 16      14 15 16 17 18 19 20      11 12 13 14 15 16 17
17 18 19 20 21 22 23      21 22 23 24 25 26 27      18 19 20 21 22 23 24
24 25 26 27 28 29 30      28 29 30 31               25 26 27 28 29 30
31

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                   1             1  2  3  4  5                   1  2  3
 2  3  4  5  6  7  8       6  7  8  9 10 11 12       4  5  6  7  8  9 10
 9 10 11 12 13 14 15      13 14 15 16 17 18 19      11 12 13 14 15 16 17
16 17 18 19 20 21 22      20 21 22 23 24 25 26      18 19 20 21 22 23 24
23 24 25 26 27 28 29      27 28 29 30               25 26 27 28 29 30 31


   firstweekday()              :it returns the first week day.it is by default 0 which specifies monday
     Ex:
        import calendar
        print(calendar.firstweekday())
     o/p:
        0
   
   isleap(year)                :it returns a boolean value i.e.,true or false true in case given year is leap else false
     Ex:
        import calendar
        print(calendar.isleap(1995))
     o/p:
        False

   monthcalendar(year,month)   :it returns the given month with each week as one list
     Ex:
        import calendar
        print(calendar.monthcalendar(1995,2))
     o/p:
        [[0, 0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26], [27, 28, 0, 0, 0, 0, 0]]

   leapdays(year1,year2)       :it reuturns number of leap years from year1 to year2
     Ex:
        import calendar
        print(calendar.leapdays(1995,2005))
     o/p:
        3
   prmonth(year,month)         :it prints given month in the given year
     Ex:
        import calendar
        print(calendar.prmonth(2018,2))
     o/p:
        February 2018
Mo Tu We Th Fr Sa Su
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28
None
  
  calendar.monthrange(year,month) :it prints the number of days in given month and starting day of the month 
  Ex:
     import calendar
     print(calendar.monthrange(1995,7))
  o/p:
     (5, 31)
  
 calendar.weekday(year,month,day) :Returns the weekday code for the given date. Weekday codes are 0 (Monday) to 6 (Sunday); 
                                   month numbers are 1 (January) to 12 (December).
  Ex:
     import calendar
     print(calendar.weekday(1995,2,16)
  o/p:
     3
   
  
               




  